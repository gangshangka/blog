<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-aa" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/17/aa/" class="article-date">
  <time class="dt-published" datetime="2025-03-17T02:00:00.000Z" itemprop="datePublished">2025-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/17/aa/">文章标题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h1><p>hello</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/17/aa/" data-id="cm8fokd1r0001rppt18k2ayh5" data-title="文章标题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-task1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/17/task1/" class="article-date">
  <time class="dt-published" datetime="2025-03-17T02:00:00.000Z" itemprop="datePublished">2025-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/17/task1/">FreeRTOS中的任务实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="任务函数的调用"><a href="#任务函数的调用" class="headerlink" title="任务函数的调用"></a>任务函数的调用</h1><ol>
<li>硬件初始化  </li>
<li>初始化与任务相关的列表  </li>
<li>创建任务 <code>xTaskCreateStatic</code>  </li>
<li>添加任务到就绪列表  </li>
<li>启动调度器  </li>
<li><code>for</code> 循环让任务死循环</li>
</ol>
<h2 id="实现具体的函数"><a href="#实现具体的函数" class="headerlink" title="实现具体的函数"></a>实现具体的函数</h2><ul>
<li><code>for</code> 循环；  </li>
<li>任务切换  </li>
<li><a target="_blank" rel="noopener" href="https://editor.csdn.net/md/?articleId=142267112">任务切换和调度函数</a></li>
</ul>
<h1 id="任务的定义与任务切换的实现"><a href="#任务的定义与任务切换的实现" class="headerlink" title="任务的定义与任务切换的实现"></a>任务的定义与任务切换的实现</h1><h2 id="实现任务创建函数"><a href="#实现任务创建函数" class="headerlink" title="实现任务创建函数"></a>实现任务创建函数</h2><p>任务的栈，任务的函数实体，实现任务控制块的创建和联系。</p>
<p>静态创建，<code>configSUPPORT_STATIC_ALLOCATION</code> 在 <code>FreeRTOSConfig.h</code> 中定义，配置为 <code>1</code>。（静态创建）</p>
<h3 id="xTaskCreateStatic-函数"><a href="#xTaskCreateStatic-函数" class="headerlink" title="xTaskCreateStatic() 函数"></a><code>xTaskCreateStatic()</code> 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t xx,           <span class="comment">// 任务入口</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> xx,       <span class="comment">// 任务名称，字符串形式</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> xx,           <span class="comment">// 任务栈大小</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * <span class="type">const</span> xx,             <span class="comment">// 任务形参</span></span></span><br><span class="line"><span class="params">    StackType_t * <span class="type">const</span> xx,      <span class="comment">// 任务句柄</span></span></span><br><span class="line"><span class="params">    TCB_t * <span class="type">const</span> xx             <span class="comment">// 任务控制块</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>静态创建任务，内嵌 <code>prvInitialiseNewTask</code> 函数。</p>
<ul>
<li><strong><code>TaskFunction_t</code></strong>：任务函数本身（在 <code>projdefs.h</code> 中重定义的空指针）。任务运行时执行此函数，任务函数必须符合 <code>void*</code> 类型。  </li>
<li><strong>运行传参</strong>：将函数指针传递给调度器，许多任务的具体实现不同，调度器运行时只需调用不同的任务函数，编译不需要硬编码不同的函数，否则调度器需要知道函数的具体实现，将函数的实现拷贝到调度器中。指针容易被赋值。  </li>
<li><strong><code>tskTaskControlBlock</code></strong>：任务的控制块，任务的状态和各种与调度相关的信息，是 FreeRTOS 调度器用来管理任务的核心结构 (<code>tcb_t</code>)。</li>
</ul>
<h3 id="TCB-并不直接暴露给用户，而是通过-TaskHandle-t-来间接访问"><a href="#TCB-并不直接暴露给用户，而是通过-TaskHandle-t-来间接访问" class="headerlink" title="TCB 并不直接暴露给用户，而是通过 TaskHandle_t 来间接访问"></a><code>TCB</code> 并不直接暴露给用户，而是通过 <code>TaskHandle_t</code> 来间接访问</h3><ul>
<li><strong><code>TaskHandle_t</code></strong>：任务句柄，在任务创建时获取，提供给用户，方便任务的挂起、恢复、删除等操作 (<code>tcb_t</code>)。  </li>
<li><strong><code>TaskFunction_t</code></strong>：<code>void*</code> 类型，任务函数类型。</li>
</ul>
<h2 id="prvInitialiseNewTask-函数"><a href="#prvInitialiseNewTask-函数" class="headerlink" title="prvInitialiseNewTask() 函数"></a><code>prvInitialiseNewTask()</code> 函数</h2><p>用于初始化新任务的 <code>TCB</code> 和相关数据结构。</p>
<h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li>任务入口</li>
<li>任务名称</li>
<li>任务栈大小</li>
<li>任务形参</li>
<li>任务句柄</li>
<li>任务控制块指针</li>
</ul>
<h3 id="获取栈顶地址"><a href="#获取栈顶地址" class="headerlink" title="获取栈顶地址"></a>获取栈顶地址</h3><p>（传入的 <code>任务控制块指针</code>（此函数参数）内部的 <code>栈起始地址</code> 加上 <code>栈大小</code>（此函数参数）减 <code>1</code> 作为栈顶地址（被重定义过的整型变量））</p>
<ul>
<li>向下做 <code>8</code> 字节对齐</li>
</ul>
<h3 id="将任务的名字存储在-TCB-中"><a href="#将任务的名字存储在-TCB-中" class="headerlink" title="将任务的名字存储在 TCB 中"></a>将任务的名字存储在 <code>TCB</code> 中</h3><ul>
<li>字符串长度小于 <code>configMAX_TASK_NAME_LEN</code> 的情况下递增循环</li>
<li>储存在 <code>xTaskCreateStatic()</code> 函数中控制块索引指针中</li>
<li>若出现 <code>0x00</code>（即以 <code>&#39;/0&#39;</code> 结尾则退出）</li>
<li>强行给最大长度的前一位置 <code>0</code></li>
</ul>
<h3 id="初始化-TCB-中的-xStateListItem-（任务节点）"><a href="#初始化-TCB-中的-xStateListItem-（任务节点）" class="headerlink" title="初始化 TCB 中的 xStateListItem （任务节点）"></a>初始化 <code>TCB</code> 中的 <code>xStateListItem</code> （任务节点）</h3><ul>
<li>使用 <code>vListInitialiseItem</code> 函数初始化链表项 <code>xStateListItem</code></li>
<li>使用 <code>listSET_LIST_ITEM_OWNER</code> 配置 <code>xStateListItem</code> 的拥有者项</li>
</ul>
<h3 id="调用函数初始化任务栈，并更新栈顶指针"><a href="#调用函数初始化任务栈，并更新栈顶指针" class="headerlink" title="调用函数初始化任务栈，并更新栈顶指针"></a>调用函数初始化任务栈，并更新栈顶指针</h3><ul>
<li>调用 <code>pxPortInitialiseStack()</code> 函数初始化任务栈，并更新栈顶指针</li>
<li>任务句柄指向任务控制块</li>
</ul>
<h2 id="pxPortInitialiseStack-函数"><a href="#pxPortInitialiseStack-函数" class="headerlink" title="pxPortInitialiseStack() 函数"></a><code>pxPortInitialiseStack()</code> 函数</h2><p>它的主要作用是为新创建的任务设置初始的栈状态（上文初始化栈状态时用到），以便任务能够正确地开始执行。确保栈的顶部包含正确的初始值。（存储的内容在异常发生时会自动加载到 CPU）</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StackType_t *pxTopOfStack,  <span class="comment">// 栈顶指针</span></span><br><span class="line">TaskFunction_t pxCode,      <span class="comment">// 任务入口函数</span></span><br><span class="line"><span class="type">void</span> *pvParameters          <span class="comment">// 任务形参</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化栈"><a href="#初始化栈" class="headerlink" title="初始化栈"></a>初始化栈</h3><ul>
<li><code>xPSR</code> 的 <code>bit24</code> 必须置 <code>1</code>（thumb 模式）</li>
<li><strong>任务的入口地址</strong>（这个函数在内存中的地址）<blockquote>
<p>当任务被创建时，FreeRTOS 会将任务入口地址（即任务函数的地址）保存到任务栈中，以便在任务切换时能够恢复这个地址并开始执行任务。</p>
</blockquote>
</li>
<li><strong>任务的返回地址</strong><blockquote>
<p>它是在任务执行过程中保存的，用于在任务切换时恢复任务的执行状态。不过 FreeRTOS 会将 <code>PC</code> 设置为 <code>prvTaskExitError</code>，而不是返回到任务的调用位置。这是为了确保任务结束后不会继续执行不应执行的代码。<br>FreeRTOS 中的任务函数通常是一个无限循环。</p>
</blockquote>
</li>
<li><code>R12</code>, <code>R3</code>, <code>R2</code> 和 <code>R1</code> 默认初始化为 <code>0</code>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/17/task1/" data-id="cm8fokd220003rppthp58405j" data-title="FreeRTOS中的任务实现" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Singleton" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/15/Singleton/" class="article-date">
  <time class="dt-published" datetime="2025-03-15T02:00:00.000Z" itemprop="datePublished">2025-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/15/Singleton/">懒汉模式与饿汉模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="懒汉模式与饿汉模式"><a href="#懒汉模式与饿汉模式" class="headerlink" title="懒汉模式与饿汉模式"></a>懒汉模式与饿汉模式</h1><h2 id="懒汉模式：获取单例时才初始化"><a href="#懒汉模式：获取单例时才初始化" class="headerlink" title="懒汉模式：获取单例时才初始化"></a>懒汉模式：获取单例时才初始化</h2><p><strong>线程不安全：</strong><br>两个线程同时判断 <code>instance</code> 为空，创建了两个 <code>instance</code> 实例，不符合单例模式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong><br>添加锁，实例还未创建时枷锁，创建实例前需要再判断一次。可能一个线程已经在创建实例了，确保不会因为枷锁期间多个线程同时进入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mtx;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="饿汉模式：在类一加载时就初始化了-instance-这个静态变量"><a href="#饿汉模式：在类一加载时就初始化了-instance-这个静态变量" class="headerlink" title="饿汉模式：在类一加载时就初始化了 instance 这个静态变量"></a>饿汉模式：在类一加载时就初始化了 <code>instance</code> 这个静态变量</h2><p>（在编译时就可以被初始化）, 不用判断是否存在，肯定已经存在，直接返回 <code>instance</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br></pre></td></tr></table></figure>

<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/15/Singleton/" data-id="cm8fokd1d0000rpptbi6f59ya" data-title="懒汉模式与饿汉模式" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-error_in_VS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/15/error_in_VS/" class="article-date">
  <time class="dt-published" datetime="2024-11-15T08:00:00.000Z" itemprop="datePublished">2024-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/15/error_in_VS/">VS上qt配置的若干问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、“There’s-no-Qt-version-assigned-to-project-WBoard-vcxproj-for-configuration-Debug-x64”错误解决办法"><a href="#一、“There’s-no-Qt-version-assigned-to-project-WBoard-vcxproj-for-configuration-Debug-x64”错误解决办法" class="headerlink" title="一、“There’s no Qt version assigned to project WBoard.vcxproj for configuration Debug&#x2F;x64”错误解决办法"></a>一、“There’s no Qt version assigned to project WBoard.vcxproj for configuration Debug&#x2F;x64”错误解决办法</h1><p>在使用 Qt 与 Visual Studio 项目时，若遇到 Debug&#x2F;x64 配置中没有指定 Qt 版本出现上述错误，可按以下步骤解决：</p>
<ol>
<li><strong>确保正确安装了 Qt</strong>：<ul>
<li>要保证系统中已正确安装 Qt，并且在 Visual Studio 中选择了正确的 Qt 版本。可通过 Qt Maintenance Tool 或从 Qt 官网下载并安装 Qt。</li>
</ul>
</li>
<li><strong>在 Visual Studio 中配置 Qt</strong>：<ul>
<li>打开项目（WBoard.vcxproj）。</li>
<li>选择“工具”-&gt;“选项”。</li>
<li>在“项目和解决方案”下，选择“Qt 项目设置”。</li>
<li>确保为项目选择了正确的 Qt 版本。若没列出任何版本，可能需要手动添加，指定 Qt 安装路径。</li>
</ul>
</li>
<li><strong>为项目分配 Qt 版本</strong>：<ul>
<li>右键点击项目（WBoard.vcxproj），然后选择“属性”。</li>
<li>在“配置属性”-&gt;“Qt 项目”下，确保“Qt 版本”字段正确设置为已安装的有效 Qt 版本。</li>
</ul>
</li>
<li><strong>设置 Qt Kits</strong>：<ul>
<li>若使用的是 Qt Creator 或手动管理 kits，确保在 Qt 设置中为 Debug&#x2F;x64 配置了正确的 kit（匹配平台和编译器）。</li>
</ul>
</li>
<li><strong>重新构建项目</strong>：<ul>
<li>配置好 Qt 版本后，重新构建项目，检查问题是否解决。</li>
</ul>
</li>
</ol>
<p>若按上述步骤操作后问题依然存在，尝试重新安装 Qt Visual Studio Tools，或检查系统中 Qt 的环境变量配置。</p>
<h4 id="二、VS2022-中检查-Qt-Version-配置与项目属性是否一致的方法"><a href="#二、VS2022-中检查-Qt-Version-配置与项目属性是否一致的方法" class="headerlink" title="二、VS2022 中检查 Qt Version 配置与项目属性是否一致的方法"></a>二、VS2022 中检查 Qt Version 配置与项目属性是否一致的方法</h4><ol>
<li><p><strong>检查 Qt 版本配置</strong>：</p>
<ul>
<li>打开 Visual Studio 2022，并确保已安装 Qt Visual Studio Tools 插件。</li>
<li>打开 Qt 项目设置：<ul>
<li>在菜单栏中，选择“工具（Tools）”-&gt;“选项（Options）”。</li>
<li>在左侧面板中，找到“Qt Project Settings”或类似选项（根据安装插件，Qt 项目设置可能在“Projects and Solutions”或单独的 Qt 选项卡下）。</li>
</ul>
</li>
<li>检查 Qt 版本：<ul>
<li>在“Qt Project Settings”中，查看“Qt Versions”，这里列出已配置的 Qt 版本。确保已选择正确版本，且该版本指向安装的 Qt 路径。</li>
<li>若 Qt 版本没配置或者未显示想要的版本，可点击“添加（Add）”按钮，选择正确的 Qt 安装路径。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>检查项目属性</strong>：</p>
<ul>
<li>打开项目属性：<ul>
<li>在解决方案资源管理器中，右键点击项目（例如 WBoard.vcxproj），然后选择“属性（Properties）”。</li>
</ul>
</li>
<li>检查 Qt 版本是否一致：<ul>
<li>在项目属性窗口中，选择“配置属性”-&gt;“Qt 项目（Qt Project）”。</li>
<li>在“Qt 版本”字段，确保它与上述配置中的 Qt 版本一致，若不一致，手动选择正确的 Qt 版本。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>检查 Qt 模块</strong>：</p>
<ul>
<li>在“Qt 项目”设置中，查看“Qt Modules”。</li>
<li>确保项目使用了正确的 Qt 模块（例如 QtCore, QtWidgets, QtGui 等），且这些模块与选择的 Qt 版本兼容。</li>
</ul>
</li>
<li><p><strong>重新生成项目</strong>：</p>
<ul>
<li>选择顶部菜单栏中的“生成（Build）”。</li>
<li>点击“重新生成解决方案（Rebuild Solution）”以确保所有配置被正确应用。</li>
</ul>
</li>
<li><p><strong>检查输出日志</strong>：<br>在重新生成项目时，查看输出窗口中的日志，看是否有关于 Qt 配置的错误信息，若 Qt 版本配置不正确，通常会看到类似“No Qt version assigned”或“Qt version mismatch”的错误信息。</p>
</li>
</ol>
<h4 id="三、Visual-Studio-Installer-中安装-MSVC-v142-工具链的步骤及相关事项"><a href="#三、Visual-Studio-Installer-中安装-MSVC-v142-工具链的步骤及相关事项" class="headerlink" title="三、Visual Studio Installer 中安装 MSVC v142 工具链的步骤及相关事项"></a>三、Visual Studio Installer 中安装 MSVC v142 工具链的步骤及相关事项</h4><ol>
<li><p><strong>详细步骤说明</strong>：</p>
<ul>
<li><strong>打开 Visual Studio Installer</strong>：<ul>
<li>在 Windows 搜索栏中输入“Visual Studio Installer”，点击打开。</li>
</ul>
</li>
<li><strong>选择要修改的 VS2022 版本</strong>：<ul>
<li>在安装器中找到已安装的“Visual Studio 2022”，点击右侧的“修改”按钮。</li>
</ul>
</li>
<li><strong>切换到“单个组件”标签页</strong>：<ul>
<li>在弹出的界面中，顶部有多个标签页（工作负载、单个组件、语言包等），点击“单个组件”。</li>
</ul>
</li>
<li><strong>搜索并勾选 MSVC v142 工具链</strong>：<ul>
<li>在搜索框中输入“v142”，找到以下组件并勾选：<ul>
<li>“MSVC v142 - VS2019 C++ x64&#x2F;x86 生成工具（最新）”（确保勾选的是针对 VS2019 的 v142 版本，而非 v143）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>完成修改并安装</strong>：<ul>
<li>点击右下角的“修改”按钮，等待安装完成。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li><strong>权限问题</strong>：<ul>
<li>如果提示需要管理员权限，请以管理员身份运行 Visual Studio Installer。</li>
</ul>
</li>
<li><strong>组件名称可能随版本变化</strong>：<ul>
<li>如果搜索不到“v142”，尝试关键词“VS2019”或“C++ 2019”。</li>
</ul>
</li>
<li><strong>工具链路径验证</strong>：<ul>
<li>安装完成后，工具链默认路径为：“C:\Program Files (x86)\Microsoft Visual Studio\2019\BuildTools\VC\Tools\MSVC\14.29.30133\”（路径中的版本号可能不同）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>为什么需要安装 MSVC v142？</strong>：</p>
<ul>
<li>若使用的 Qt 版本是“Qt 5.15.2 (msvc2019)”，它依赖的是 VS2019 的编译器（MSVC v142）。</li>
<li>VS2022 默认安装的是“MSVC v143”编译器，两者不兼容，通过安装 v142 工具链，可以让 VS2022 兼容旧版 Qt。</li>
</ul>
</li>
<li><p><strong>验证是否安装成功</strong>：</p>
<ul>
<li>打开 VS2022，创建一个空的 C++ 控制台项目。</li>
<li>右键项目 &gt;“属性”&gt;“配置属性”&gt;“常规”，检查“平台工具集”是否包含“Visual Studio 2019 (v142)”。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/15/error_in_VS/" data-id="cm8fokd1z0002rppt59l1e2l9" data-title="VS上qt配置的若干问题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-wsl_network_error" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/15/wsl_network_error/" class="article-date">
  <time class="dt-published" datetime="2024-11-15T08:00:00.000Z" itemprop="datePublished">2024-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/15/wsl_network_error/">WSL2的网络问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Ubuntu-APT-Update-卡住的排查与解决方案"><a href="#Ubuntu-APT-Update-卡住的排查与解决方案" class="headerlink" title="Ubuntu APT Update 卡住的排查与解决方案"></a>Ubuntu APT Update 卡住的排查与解决方案</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在使用 Ubuntu 进行 <code>sudo apt-get update</code> 时，发现更新一直卡在 <code>Connecting to 172.23.153.121</code>，并最终超时。起初以为是网络问题，但 <code>ping archive.ubuntu.com</code> 和 <code>ping security.ubuntu.com</code> 都能返回数据，说明基础网络是通的。</p>
<p>深入排查后，发现 <code>APT</code> 可能被配置了错误的代理或镜像源，导致更新请求被错误地重定向到 <code>172.23.153.121</code>，最终导致超时。以下是详细的排查过程和解决方案。</p>
<hr>
<h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="1-检查-APT-源是否正确"><a href="#1-检查-APT-源是否正确" class="headerlink" title="1. 检查 APT 源是否正确"></a>1. 检查 APT 源是否正确</h3><p>首先查看 <code>/etc/apt/sources.list</code>，确认是否存在错误的源配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>我的 <code>sources.list</code> 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deb http://archive.ubuntu.com/ubuntu focal main restricted universe multiverse</span><br><span class="line">deb http://security.ubuntu.com/ubuntu focal-security main restricted universe multiverse</span><br><span class="line">deb http://archive.ubuntu.com/ubuntu focal-updates main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p>看起来没有问题，说明问题不是由于源地址错误引起的。</p>
<hr>
<h3 id="2-检查-APT-代理设置"><a href="#2-检查-APT-代理设置" class="headerlink" title="2. 检查 APT 代理设置"></a>2. 检查 APT 代理设置</h3><p>APT 可能被配置了一个错误的代理，导致所有请求都被重定向。检查 <code>apt.conf.d</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r <span class="string">&quot;172.23.153.121&quot;</span> /etc/apt/apt.conf.d/</span><br></pre></td></tr></table></figure>

<p>果然，发现了类似的代理配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/apt/apt.conf.d/00proxy:Acquire::http::Proxy &quot;http://172.23.153.121:80/&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="解决方案：删除或修改该文件"><a href="#解决方案：删除或修改该文件" class="headerlink" title="解决方案：删除或修改该文件"></a>解决方案：删除或修改该文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /etc/apt/apt.conf.d/00proxy</span><br></pre></td></tr></table></figure>
<p>或者手动编辑：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/apt/apt.conf.d/00proxy</span><br></pre></td></tr></table></figure>
<p>删除 <code>Acquire::http::Proxy</code> 相关的行，保存退出。</p>
<hr>
<h3 id="3-检查环境变量中的代理"><a href="#3-检查环境变量中的代理" class="headerlink" title="3. 检查环境变量中的代理"></a>3. 检查环境变量中的代理</h3><p>如果 <code>apt.conf.d</code> 没有问题，可能是系统环境变量导致的。执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">env</span> | grep -i proxy</span><br></pre></td></tr></table></figure>
<p>如果返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=http://172.23.153.121:80</span><br><span class="line">https_proxy=http://172.23.153.121:80</span><br></pre></td></tr></table></figure>
<p>那么需要取消代理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br></pre></td></tr></table></figure>
<p>并检查 <code>bash</code> 配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i proxy ~/.bashrc ~/.bash_profile ~/.profile /etc/environment /etc/bash.bashrc /etc/profile</span><br></pre></td></tr></table></figure>
<p>如果发现 <code>export http_proxy</code> 或 <code>export https_proxy</code>，需要手动编辑相应文件删除，并执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/environment</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-清除-APT-缓存并重试"><a href="#4-清除-APT-缓存并重试" class="headerlink" title="4. 清除 APT 缓存并重试"></a>4. 清除 APT 缓存并重试</h3><p>清除旧的 APT 数据，防止缓存影响：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><span class="line"><span class="built_in">sudo</span> apt-get clean</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-检查-DNS-设置"><a href="#5-检查-DNS-设置" class="headerlink" title="5. 检查 DNS 设置"></a>5. 检查 DNS 设置</h3><p>如果问题依然存在，可能是 DNS 解析问题。查看 DNS 配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/resolv.conf</span><br></pre></td></tr></table></figure>
<p>如果 DNS 服务器不是 <code>8.8.8.8</code> 或 <code>8.8.4.4</code>，可以手动修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/resolv.conf</span><br></pre></td></tr></table></figure>
<p>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 8.8.4.4</span><br></pre></td></tr></table></figure>
<p>然后再次运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-强制-APT-使用-IPv4"><a href="#6-强制-APT-使用-IPv4" class="headerlink" title="6. 强制 APT 使用 IPv4"></a>6. 强制 APT 使用 IPv4</h3><p>如果仍然超时，尝试强制 APT 仅使用 IPv4：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update -o Acquire::ForceIPv4=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-更换国内镜像源（可选）"><a href="#7-更换国内镜像源（可选）" class="headerlink" title="7. 更换国内镜像源（可选）"></a>7. 更换国内镜像源（可选）</h3><p>如果你在国内，使用官方的 <code>archive.ubuntu.com</code> 可能会较慢，可以更换为阿里云或清华源。</p>
<p>编辑 <code>/etc/apt/sources.list</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>替换为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu focal-updates main restricted universe multiverse</span><br></pre></td></tr></table></figure>
<p>然后更新：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><strong>检查 APT 代理配置</strong> (<code>/etc/apt/apt.conf.d/</code>)，删除错误的代理设置。</li>
<li><strong>检查系统环境变量</strong> (<code>env | grep -i proxy</code>)，删除不必要的代理。</li>
<li><strong>清理 APT 缓存</strong> (<code>sudo rm -rf /var/lib/apt/lists/* &amp;&amp; sudo apt-get clean</code>)。</li>
<li><strong>修复 DNS 设置</strong> (<code>sudo nano /etc/resolv.conf</code>，改成 <code>8.8.8.8</code>)。</li>
<li><strong>强制使用 IPv4</strong> (<code>sudo apt-get update -o Acquire::ForceIPv4=true</code>)。</li>
<li><strong>更换国内镜像源</strong>（阿里云、清华等）。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/15/wsl_network_error/" data-id="cm8fokd260004rppt35tv42z6" data-title="WSL2的网络问题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/17/aa/">文章标题</a>
          </li>
        
          <li>
            <a href="/2025/03/17/task1/">FreeRTOS中的任务实现</a>
          </li>
        
          <li>
            <a href="/2025/03/15/Singleton/">懒汉模式与饿汉模式</a>
          </li>
        
          <li>
            <a href="/2024/11/15/error_in_VS/">VS上qt配置的若干问题</a>
          </li>
        
          <li>
            <a href="/2024/11/15/wsl_network_error/">WSL2的网络问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>