<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-aa" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/17/aa/" class="article-date">
  <time class="dt-published" datetime="2025-03-17T02:00:00.000Z" itemprop="datePublished">2025-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/17/aa/">文章标题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h1><p>hello</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/17/aa/" data-id="cm8fndp580002xlptfwi84ypm" data-title="文章标题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-album" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/17/album/" class="article-date">
  <time class="dt-published" datetime="2025-03-17T02:00:00.000Z" itemprop="datePublished">2025-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/17/album/">QT电子相册题目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="1-请介绍一下这个项目的核心功能是什么？"><a href="#1-请介绍一下这个项目的核心功能是什么？" class="headerlink" title="1. 请介绍一下这个项目的核心功能是什么？"></a>1. <strong>请介绍一下这个项目的核心功能是什么？</strong></h3><p><strong>解答：</strong><br>该项目是一个基于Qt的桌面应用，主要用于项目管理和图片浏览。核心功能包括：</p>
<ul>
<li>项目目录树管理，支持项目的创建、删除与路径验证。</li>
<li>文件夹导入功能，能够通过选择文件夹并导入其内容到项目目录。</li>
<li>图片展示与切换，用户可以通过双击目录树中的图片文件进行展示，并通过前进和后退按钮切换图片。</li>
<li>使用 <code>QWizard</code> 向导引导用户创建新项目，并进行路径和字段验证。</li>
</ul>
<h3 id="2-你在项目中使用了哪些Qt控件？"><a href="#2-你在项目中使用了哪些Qt控件？" class="headerlink" title="2. 你在项目中使用了哪些Qt控件？"></a>2. <strong>你在项目中使用了哪些Qt控件？</strong></h3><p><strong>解答：</strong><br>在这个项目中，我使用了多个Qt控件，包括：</p>
<ul>
<li><code>QTreeWidget</code> 和 <code>QTreeWidgetItem</code> 用于实现项目目录树。</li>
<li><code>QPushButton</code> 和自定义的 <code>PicButton</code> 用于实现按钮的动态效果（如悬停、点击等）。</li>
<li><code>QWizard</code> 用于设计项目创建向导，提供步骤式输入。</li>
<li><code>QFileDialog</code> 用于选择文件夹导入，支持目录选择。</li>
<li><code>QProgressDialog</code> 显示导入进度。</li>
<li><code>QGraphicsOpacityEffect</code> 和 <code>QPropertyAnimation</code> 用于实现按钮的渐隐效果。</li>
</ul>
<h3 id="3-你如何确保导入文件夹的操作不会阻塞UI线程？"><a href="#3-你如何确保导入文件夹的操作不会阻塞UI线程？" class="headerlink" title="3. 你如何确保导入文件夹的操作不会阻塞UI线程？"></a>3. <strong>你如何确保导入文件夹的操作不会阻塞UI线程？</strong></h3><p><strong>解答：</strong><br>为了避免文件导入过程阻塞UI线程，我将文件导入操作放入了一个独立的线程中。通过继承 <code>QThread</code> 创建 <code>ProTreeThread</code>，在该线程中执行文件复制，并使用 <code>QProgressDialog</code> 来显示导入进度。这样，UI线程能够继续响应用户操作，确保应用的流畅性。</p>
<h3 id="4-为什么选择使用-QWizard-作为项目创建的向导？"><a href="#4-为什么选择使用-QWizard-作为项目创建的向导？" class="headerlink" title="4. 为什么选择使用 QWizard 作为项目创建的向导？"></a>4. <strong>为什么选择使用 <code>QWizard</code> 作为项目创建的向导？</strong></h3><p><strong>解答：</strong><br><code>QWizard</code> 提供了一个分步式的界面，特别适合需要逐步配置的场景，如项目创建。在这个项目中，<code>QWizard</code> 可以引导用户逐步输入项目名称和路径，并进行实时的验证。使用 <code>QWizard</code> 可以有效提高用户体验，确保输入的合法性。</p>
<h3 id="5-如何处理项目目录树中的重复项目名？"><a href="#5-如何处理项目目录树中的重复项目名？" class="headerlink" title="5. 如何处理项目目录树中的重复项目名？"></a>5. <strong>如何处理项目目录树中的重复项目名？</strong></h3><p><strong>解答：</strong><br>在添加项目到目录树时，我使用了 <code>QSet</code> 来存储已存在的项目路径，并进行查重。如果新项目的路径已经存在于 <code>QSet</code> 中，则拒绝添加，避免了重复项目名的问题。</p>
<h3 id="6-你如何处理文件夹导入的进度显示？"><a href="#6-你如何处理文件夹导入的进度显示？" class="headerlink" title="6. 你如何处理文件夹导入的进度显示？"></a>6. <strong>你如何处理文件夹导入的进度显示？</strong></h3><p><strong>解答：</strong><br>在文件夹导入过程中，我创建了一个多线程任务来执行文件复制操作，并使用 <code>QProgressDialog</code> 来显示进度。当文件导入开始时，<code>QProgressDialog</code> 会展示文件复制的进度条，用户可以实时看到进度，并在导入过程中取消操作。线程完成后，进度条会自动更新，确保用户了解操作的实时状态。</p>
<h3 id="7-你是如何优化界面交互的？"><a href="#7-你是如何优化界面交互的？" class="headerlink" title="7. 你是如何优化界面交互的？"></a>7. <strong>你是如何优化界面交互的？</strong></h3><p><strong>解答：</strong><br>为了提升界面交互体验，我使用了动态效果和美化：</p>
<ul>
<li>使用 <code>QPropertyAnimation</code> 实现按钮的渐隐效果，当鼠标进入或离开按钮区域时，按钮的透明度会平滑变化。</li>
<li>在 <code>QPushButton</code> 上自定义了鼠标悬停、点击效果，使用 <code>QPixmap</code> 加载不同的图标，增加按钮的互动性。</li>
<li>通过 <code>QSS</code> 自定义了窗口和控件的样式，提升了应用的视觉效果。</li>
</ul>
<hr>
<hr>
<h3 id="1-QSS是什么，你是在哪里应用的，有什么效果？"><a href="#1-QSS是什么，你是在哪里应用的，有什么效果？" class="headerlink" title="1. QSS是什么，你是在哪里应用的，有什么效果？"></a>1. <strong>QSS是什么，你是在哪里应用的，有什么效果？</strong></h3><p><strong>解答：</strong><br><code>QSS</code>（Qt样式表，Qt Style Sheets）是Qt提供的一种类似于CSS的样式表，用于控制应用程序界面中控件的外观和布局。通过 <code>QSS</code>，我们可以对Qt的各类控件（如按钮、菜单、窗口、标签等）进行样式定制，包括颜色、字体、边框、背景等。</p>
<p>在这个项目中，我使用 <code>QSS</code> 自定义了以下内容：</p>
<ul>
<li><strong>主窗口和菜单栏样式</strong>：设置了背景色、字体颜色等，确保界面统一且符合设计需求。</li>
<li><strong>按钮样式</strong>：定义了按钮的边框、背景色和鼠标悬停&#x2F;点击效果，增强了用户体验。</li>
<li><strong>菜单选中效果</strong>：为菜单项设置了选中时的高亮效果，提升了界面的交互性。</li>
</ul>
<p>通过 <code>QSS</code>，我们能够快速而有效地调整界面外观，使得界面更加美观且具有现代感。</p>
<hr>
<h3 id="2-项目目录树是怎么实现的？"><a href="#2-项目目录树是怎么实现的？" class="headerlink" title="2. 项目目录树是怎么实现的？"></a>2. <strong>项目目录树是怎么实现的？</strong></h3><p><strong>解答：</strong><br>项目目录树是通过 <code>QTreeWidget</code> 控件实现的。为了适应项目需求，我对 <code>QTreeWidgetItem</code> 进行了自定义，创建了一个名为 <code>ProTreeItem</code> 的类，用于表示每个目录树的节点。该类继承自 <code>QTreeWidgetItem</code>，并添加了自定义属性（如项目路径、名称、根节点、前后节点等）和方法。</p>
<p>在具体实现中：</p>
<ul>
<li>使用 <code>QTreeWidget</code> 来显示整个项目目录树。</li>
<li><code>ProTreeItem</code> 用于表示树中的每个节点，节点可以包含文件夹或文件，并且每个节点都包含路径、名称等信息。</li>
<li>通过 <code>QSet</code> 存储已加载的路径，避免了重复加载同一个项目。</li>
<li>右键点击树项时，弹出了导入文件夹、设置活动项目等操作。</li>
</ul>
<p>这种设计确保了项目目录树的层级结构清晰，且可以灵活管理项目中的文件和文件夹。</p>
<hr>
<h3 id="3-QWizard-怎样设计的动态字段验证？"><a href="#3-QWizard-怎样设计的动态字段验证？" class="headerlink" title="3. QWizard 怎样设计的动态字段验证？"></a>3. <strong>QWizard 怎样设计的动态字段验证？</strong></h3><p><strong>解答：</strong><br>在项目创建的向导中，我使用了 <code>QWizard</code> 来引导用户逐步填写项目名称和路径。为了确保用户输入的内容有效，我对向导中的字段（如 <code>QLineEdit</code> 控件）进行了动态验证。</p>
<p>具体步骤：</p>
<ol>
<li><strong>字段注册</strong>：通过 <code>registerField</code> 将 <code>QLineEdit</code> 控件与 <code>QWizard</code> 的字段绑定，确保字段与向导的状态关联。</li>
<li><strong>字段验证</strong>：通过 <code>textEdited</code> 信号监听输入内容的变化，动态触发验证。每次用户编辑字段内容时，都会检查输入的有效性。</li>
<li><strong>验证逻辑</strong>：<ul>
<li>在 <code>ProSetPage</code> 页面的 <code>isComplete</code> 函数中，进行路径合法性检查，确保用户输入的项目路径存在且有效。</li>
<li>如果字段未填写或者路径无效，<code>isComplete</code> 返回 <code>false</code>，禁止用户继续操作。</li>
</ul>
</li>
</ol>
<p>这种动态验证机制保证了用户输入的合法性，并通过实时反馈提高了用户体验。</p>
<hr>
<h3 id="4-怎样使用多线程优化文件导入，显示导入进度？"><a href="#4-怎样使用多线程优化文件导入，显示导入进度？" class="headerlink" title="4. 怎样使用多线程优化文件导入，显示导入进度？"></a>4. <strong>怎样使用多线程优化文件导入，显示导入进度？</strong></h3><p><strong>解答：</strong><br>为了避免文件导入操作阻塞UI线程，我使用了多线程来异步处理文件复制操作。具体实现如下：</p>
<ol>
<li><strong>创建自定义线程</strong>：我继承了 <code>QThread</code> 类，创建了 <code>ProTreeThread</code> 线程类来处理文件导入任务。线程中执行的是文件复制和目录创建的逻辑。</li>
<li><strong>进度显示</strong>：使用 <code>QProgressDialog</code> 来显示文件导入的进度。在多线程中，我通过发出信号（如 <code>SigUpdateProgress</code>）来更新进度条，使用户实时看到导入进度。</li>
<li><strong>线程控制</strong>：线程执行文件导入时，如果用户取消操作，通过设置 <code>bstop</code> 标志来终止线程，确保可以安全退出。</li>
<li><strong>UI线程与子线程的通信</strong>：在子线程中通过信号与主线程通信，当文件复制完成时发出 <code>SigFinishProgress</code> 信号，通知进度对话框完成导入操作。</li>
</ol>
<p>通过多线程和进度条的配合，文件导入操作得到了显著优化，避免了界面卡顿，并提升了用户的使用体验。</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/17/album/" data-id="cm8fndp5c0003xlpt23s1h972" data-title="QT电子相册题目" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-task1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/17/task1/" class="article-date">
  <time class="dt-published" datetime="2025-03-17T02:00:00.000Z" itemprop="datePublished">2025-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/17/task1/">FreeRTOS中的任务实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="任务函数的调用"><a href="#任务函数的调用" class="headerlink" title="任务函数的调用"></a>任务函数的调用</h1><ol>
<li>硬件初始化  </li>
<li>初始化与任务相关的列表  </li>
<li>创建任务 <code>xTaskCreateStatic</code>  </li>
<li>添加任务到就绪列表  </li>
<li>启动调度器  </li>
<li><code>for</code> 循环让任务死循环</li>
</ol>
<h2 id="实现具体的函数"><a href="#实现具体的函数" class="headerlink" title="实现具体的函数"></a>实现具体的函数</h2><ul>
<li><code>for</code> 循环；  </li>
<li>任务切换  </li>
<li><a target="_blank" rel="noopener" href="https://editor.csdn.net/md/?articleId=142267112">任务切换和调度函数</a></li>
</ul>
<h1 id="任务的定义与任务切换的实现"><a href="#任务的定义与任务切换的实现" class="headerlink" title="任务的定义与任务切换的实现"></a>任务的定义与任务切换的实现</h1><h2 id="实现任务创建函数"><a href="#实现任务创建函数" class="headerlink" title="实现任务创建函数"></a>实现任务创建函数</h2><p>任务的栈，任务的函数实体，实现任务控制块的创建和联系。</p>
<p>静态创建，<code>configSUPPORT_STATIC_ALLOCATION</code> 在 <code>FreeRTOSConfig.h</code> 中定义，配置为 <code>1</code>。（静态创建）</p>
<h3 id="xTaskCreateStatic-函数"><a href="#xTaskCreateStatic-函数" class="headerlink" title="xTaskCreateStatic() 函数"></a><code>xTaskCreateStatic()</code> 函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TaskHandle_t <span class="title function_">xTaskCreateStatic</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t xx,           <span class="comment">// 任务入口</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> xx,       <span class="comment">// 任务名称，字符串形式</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">uint32_t</span> xx,           <span class="comment">// 任务栈大小</span></span></span><br><span class="line"><span class="params">    <span class="type">void</span> * <span class="type">const</span> xx,             <span class="comment">// 任务形参</span></span></span><br><span class="line"><span class="params">    StackType_t * <span class="type">const</span> xx,      <span class="comment">// 任务句柄</span></span></span><br><span class="line"><span class="params">    TCB_t * <span class="type">const</span> xx             <span class="comment">// 任务控制块</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>静态创建任务，内嵌 <code>prvInitialiseNewTask</code> 函数。</p>
<ul>
<li><strong><code>TaskFunction_t</code></strong>：任务函数本身（在 <code>projdefs.h</code> 中重定义的空指针）。任务运行时执行此函数，任务函数必须符合 <code>void*</code> 类型。  </li>
<li><strong>运行传参</strong>：将函数指针传递给调度器，许多任务的具体实现不同，调度器运行时只需调用不同的任务函数，编译不需要硬编码不同的函数，否则调度器需要知道函数的具体实现，将函数的实现拷贝到调度器中。指针容易被赋值。  </li>
<li><strong><code>tskTaskControlBlock</code></strong>：任务的控制块，任务的状态和各种与调度相关的信息，是 FreeRTOS 调度器用来管理任务的核心结构 (<code>tcb_t</code>)。</li>
</ul>
<h3 id="TCB-并不直接暴露给用户，而是通过-TaskHandle-t-来间接访问"><a href="#TCB-并不直接暴露给用户，而是通过-TaskHandle-t-来间接访问" class="headerlink" title="TCB 并不直接暴露给用户，而是通过 TaskHandle_t 来间接访问"></a><code>TCB</code> 并不直接暴露给用户，而是通过 <code>TaskHandle_t</code> 来间接访问</h3><ul>
<li><strong><code>TaskHandle_t</code></strong>：任务句柄，在任务创建时获取，提供给用户，方便任务的挂起、恢复、删除等操作 (<code>tcb_t</code>)。  </li>
<li><strong><code>TaskFunction_t</code></strong>：<code>void*</code> 类型，任务函数类型。</li>
</ul>
<h2 id="prvInitialiseNewTask-函数"><a href="#prvInitialiseNewTask-函数" class="headerlink" title="prvInitialiseNewTask() 函数"></a><code>prvInitialiseNewTask()</code> 函数</h2><p>用于初始化新任务的 <code>TCB</code> 和相关数据结构。</p>
<h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><ul>
<li>任务入口</li>
<li>任务名称</li>
<li>任务栈大小</li>
<li>任务形参</li>
<li>任务句柄</li>
<li>任务控制块指针</li>
</ul>
<h3 id="获取栈顶地址"><a href="#获取栈顶地址" class="headerlink" title="获取栈顶地址"></a>获取栈顶地址</h3><p>（传入的 <code>任务控制块指针</code>（此函数参数）内部的 <code>栈起始地址</code> 加上 <code>栈大小</code>（此函数参数）减 <code>1</code> 作为栈顶地址（被重定义过的整型变量））</p>
<ul>
<li>向下做 <code>8</code> 字节对齐</li>
</ul>
<h3 id="将任务的名字存储在-TCB-中"><a href="#将任务的名字存储在-TCB-中" class="headerlink" title="将任务的名字存储在 TCB 中"></a>将任务的名字存储在 <code>TCB</code> 中</h3><ul>
<li>字符串长度小于 <code>configMAX_TASK_NAME_LEN</code> 的情况下递增循环</li>
<li>储存在 <code>xTaskCreateStatic()</code> 函数中控制块索引指针中</li>
<li>若出现 <code>0x00</code>（即以 <code>&#39;/0&#39;</code> 结尾则退出）</li>
<li>强行给最大长度的前一位置 <code>0</code></li>
</ul>
<h3 id="初始化-TCB-中的-xStateListItem-（任务节点）"><a href="#初始化-TCB-中的-xStateListItem-（任务节点）" class="headerlink" title="初始化 TCB 中的 xStateListItem （任务节点）"></a>初始化 <code>TCB</code> 中的 <code>xStateListItem</code> （任务节点）</h3><ul>
<li>使用 <code>vListInitialiseItem</code> 函数初始化链表项 <code>xStateListItem</code></li>
<li>使用 <code>listSET_LIST_ITEM_OWNER</code> 配置 <code>xStateListItem</code> 的拥有者项</li>
</ul>
<h3 id="调用函数初始化任务栈，并更新栈顶指针"><a href="#调用函数初始化任务栈，并更新栈顶指针" class="headerlink" title="调用函数初始化任务栈，并更新栈顶指针"></a>调用函数初始化任务栈，并更新栈顶指针</h3><ul>
<li>调用 <code>pxPortInitialiseStack()</code> 函数初始化任务栈，并更新栈顶指针</li>
<li>任务句柄指向任务控制块</li>
</ul>
<h2 id="pxPortInitialiseStack-函数"><a href="#pxPortInitialiseStack-函数" class="headerlink" title="pxPortInitialiseStack() 函数"></a><code>pxPortInitialiseStack()</code> 函数</h2><p>它的主要作用是为新创建的任务设置初始的栈状态（上文初始化栈状态时用到），以便任务能够正确地开始执行。确保栈的顶部包含正确的初始值。（存储的内容在异常发生时会自动加载到 CPU）</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StackType_t *pxTopOfStack,  <span class="comment">// 栈顶指针</span></span><br><span class="line">TaskFunction_t pxCode,      <span class="comment">// 任务入口函数</span></span><br><span class="line"><span class="type">void</span> *pvParameters          <span class="comment">// 任务形参</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化栈"><a href="#初始化栈" class="headerlink" title="初始化栈"></a>初始化栈</h3><ul>
<li><code>xPSR</code> 的 <code>bit24</code> 必须置 <code>1</code>（thumb 模式）</li>
<li><strong>任务的入口地址</strong>（这个函数在内存中的地址）<blockquote>
<p>当任务被创建时，FreeRTOS 会将任务入口地址（即任务函数的地址）保存到任务栈中，以便在任务切换时能够恢复这个地址并开始执行任务。</p>
</blockquote>
</li>
<li><strong>任务的返回地址</strong><blockquote>
<p>它是在任务执行过程中保存的，用于在任务切换时恢复任务的执行状态。不过 FreeRTOS 会将 <code>PC</code> 设置为 <code>prvTaskExitError</code>，而不是返回到任务的调用位置。这是为了确保任务结束后不会继续执行不应执行的代码。<br>FreeRTOS 中的任务函数通常是一个无限循环。</p>
</blockquote>
</li>
<li><code>R12</code>, <code>R3</code>, <code>R2</code> 和 <code>R1</code> 默认初始化为 <code>0</code>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/17/task1/" data-id="cm8fndp5i0005xlptfcll772j" data-title="FreeRTOS中的任务实现" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-VS2022&amp;MSVC2019" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/16/VS2022&MSVC2019/" class="article-date">
  <time class="dt-published" datetime="2025-03-16T02:00:00.000Z" itemprop="datePublished">2025-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/16/VS2022&MSVC2019/">VS2022不支持MSVC2019</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="VS2022不支持MSVC2019"><a href="#VS2022不支持MSVC2019" class="headerlink" title="VS2022不支持MSVC2019"></a>VS2022不支持MSVC2019</h1><p>在Visual Studio Installer中找到 <strong>修改 &gt; 单个组件</strong> 的步骤如下：</p>
<hr>
<h3 id="详细步骤说明"><a href="#详细步骤说明" class="headerlink" title="详细步骤说明"></a><strong>详细步骤说明</strong></h3><ol>
<li><p><strong>打开Visual Studio Installer</strong>：</p>
<ul>
<li>在Windows搜索栏中输入 <strong>Visual Studio Installer</strong>，点击打开。<br><img src="https://placehold.co/600x400?text=Search+Visual+Studio+Installer" alt="打开Visual Studio Installer"></li>
</ul>
</li>
<li><p><strong>选择要修改的VS2022版本</strong>：</p>
<ul>
<li>在安装器中找到已安装的 <strong>Visual Studio 2022</strong>，点击右侧的 <strong>修改</strong> 按钮。<br><img src="https://placehold.co/600x400?text=Click+Modify+Button" alt="点击“修改”按钮"></li>
</ul>
</li>
<li><p><strong>切换到“单个组件”标签页</strong>：</p>
<ul>
<li>在弹出的界面中，顶部有多个标签页（工作负载、单个组件、语言包等），点击 <strong>单个组件</strong>。<br><img src="https://placehold.co/600x400?text=Switch+to+Individual+Components+Tab" alt="切换到“单个组件”标签页"></li>
</ul>
</li>
<li><p><strong>搜索并勾选MSVC v142工具链</strong>：</p>
<ul>
<li>在搜索框中输入 <strong>v142</strong>，找到以下组件并勾选：<ul>
<li><strong>MSVC v142 - VS2019 C++ x64&#x2F;x86生成工具（最新）</strong><br>（确保勾选的是针对VS2019的v142版本，而非v143）。<br><img src="https://placehold.co/600x400?text=Search+v142+Component" alt="搜索v142组件"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>完成修改并安装</strong>：</p>
<ul>
<li>点击右下角的 <strong>修改</strong> 按钮，等待安装完成。<br><img src="https://placehold.co/600x400?text=Click+Modify+to+Install" alt="点击“修改”按钮安装"></li>
</ul>
</li>
</ol>
<hr>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol>
<li><p><strong>权限问题</strong>：</p>
<ul>
<li>如果提示需要管理员权限，请以管理员身份运行Visual Studio Installer。</li>
</ul>
</li>
<li><p><strong>组件名称可能随版本变化</strong>：</p>
<ul>
<li>如果搜索不到 <code>v142</code>，尝试关键词 <code>VS2019</code> 或 <code>C++ 2019</code>。</li>
</ul>
</li>
<li><p><strong>工具链路径验证</strong>：</p>
<ul>
<li>安装完成后，工具链默认路径为：<br><code>C:\Program Files (x86)\Microsoft Visual Studio\2019\BuildTools\VC\Tools\MSVC\14.29.30133\</code><br>（路径中的版本号可能不同）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="为什么需要安装MSVC-v142？"><a href="#为什么需要安装MSVC-v142？" class="headerlink" title="为什么需要安装MSVC v142？"></a><strong>为什么需要安装MSVC v142？</strong></h3><ul>
<li>若你使用的Qt版本是 <strong>Qt 5.15.2 (msvc2019)</strong>，它依赖的是VS2019的编译器（MSVC v142）。  </li>
<li>VS2022默认安装的是 <strong>MSVC v143</strong> 编译器，两者不兼容。  </li>
<li>通过安装v142工具链，可以让VS2022兼容旧版Qt。</li>
</ul>
<hr>
<h3 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a><strong>验证是否安装成功</strong></h3><ol>
<li>打开VS2022，创建一个空的C++控制台项目。</li>
<li>右键项目 &gt; <strong>属性 &gt; 配置属性 &gt; 常规</strong>，检查 <strong>平台工具集</strong> 是否包含 <strong>Visual Studio 2019 (v142)</strong>。<br><img src="https://placehold.co/600x400?text=Check+Platform+Toolset" alt="检查平台工具集"></li>
</ol>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/16/VS2022&MSVC2019/" data-id="cm8fndp500001xlpteguy2g9c" data-title="VS2022不支持MSVC2019" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Singleton" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/03/15/Singleton/" class="article-date">
  <time class="dt-published" datetime="2025-03-15T02:00:00.000Z" itemprop="datePublished">2025-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/03/15/Singleton/">懒汉模式与饿汉模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="懒汉模式与饿汉模式"><a href="#懒汉模式与饿汉模式" class="headerlink" title="懒汉模式与饿汉模式"></a>懒汉模式与饿汉模式</h1><h2 id="懒汉模式：获取单例时才初始化"><a href="#懒汉模式：获取单例时才初始化" class="headerlink" title="懒汉模式：获取单例时才初始化"></a>懒汉模式：获取单例时才初始化</h2><p><strong>线程不安全：</strong><br>两个线程同时判断 <code>instance</code> 为空，创建了两个 <code>instance</code> 实例，不符合单例模式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong><br>添加锁，实例还未创建时枷锁，创建实例前需要再判断一次。可能一个线程已经在创建实例了，确保不会因为枷锁期间多个线程同时进入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="type">static</span> std::mutex mtx;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="literal">nullptr</span>;</span><br><span class="line">std::mutex Singleton::mtx;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="饿汉模式：在类一加载时就初始化了-instance-这个静态变量"><a href="#饿汉模式：在类一加载时就初始化了-instance-这个静态变量" class="headerlink" title="饿汉模式：在类一加载时就初始化了 instance 这个静态变量"></a>饿汉模式：在类一加载时就初始化了 <code>instance</code> 这个静态变量</h2><p>（在编译时就可以被初始化）, 不用判断是否存在，肯定已经存在，直接返回 <code>instance</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton* instance;</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton* Singleton::instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br></pre></td></tr></table></figure>

<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/03/15/Singleton/" data-id="cm8fndp4i0000xlpt3h759b4t" data-title="懒汉模式与饿汉模式" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-error_in_VS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/15/error_in_VS/" class="article-date">
  <time class="dt-published" datetime="2024-11-15T08:00:00.000Z" itemprop="datePublished">2024-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/15/error_in_VS/">VS上qt配置的若干问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="一、“There’s-no-Qt-version-assigned-to-project-WBoard-vcxproj-for-configuration-Debug-x64”错误解决办法"><a href="#一、“There’s-no-Qt-version-assigned-to-project-WBoard-vcxproj-for-configuration-Debug-x64”错误解决办法" class="headerlink" title="一、“There’s no Qt version assigned to project WBoard.vcxproj for configuration Debug&#x2F;x64”错误解决办法"></a>一、“There’s no Qt version assigned to project WBoard.vcxproj for configuration Debug&#x2F;x64”错误解决办法</h1><p>在使用 Qt 与 Visual Studio 项目时，若遇到 Debug&#x2F;x64 配置中没有指定 Qt 版本出现上述错误，可按以下步骤解决：</p>
<ol>
<li><strong>确保正确安装了 Qt</strong>：<ul>
<li>要保证系统中已正确安装 Qt，并且在 Visual Studio 中选择了正确的 Qt 版本。可通过 Qt Maintenance Tool 或从 Qt 官网下载并安装 Qt。</li>
</ul>
</li>
<li><strong>在 Visual Studio 中配置 Qt</strong>：<ul>
<li>打开项目（WBoard.vcxproj）。</li>
<li>选择“工具”-&gt;“选项”。</li>
<li>在“项目和解决方案”下，选择“Qt 项目设置”。</li>
<li>确保为项目选择了正确的 Qt 版本。若没列出任何版本，可能需要手动添加，指定 Qt 安装路径。</li>
</ul>
</li>
<li><strong>为项目分配 Qt 版本</strong>：<ul>
<li>右键点击项目（WBoard.vcxproj），然后选择“属性”。</li>
<li>在“配置属性”-&gt;“Qt 项目”下，确保“Qt 版本”字段正确设置为已安装的有效 Qt 版本。</li>
</ul>
</li>
<li><strong>设置 Qt Kits</strong>：<ul>
<li>若使用的是 Qt Creator 或手动管理 kits，确保在 Qt 设置中为 Debug&#x2F;x64 配置了正确的 kit（匹配平台和编译器）。</li>
</ul>
</li>
<li><strong>重新构建项目</strong>：<ul>
<li>配置好 Qt 版本后，重新构建项目，检查问题是否解决。</li>
</ul>
</li>
</ol>
<p>若按上述步骤操作后问题依然存在，尝试重新安装 Qt Visual Studio Tools，或检查系统中 Qt 的环境变量配置。</p>
<h4 id="二、VS2022-中检查-Qt-Version-配置与项目属性是否一致的方法"><a href="#二、VS2022-中检查-Qt-Version-配置与项目属性是否一致的方法" class="headerlink" title="二、VS2022 中检查 Qt Version 配置与项目属性是否一致的方法"></a>二、VS2022 中检查 Qt Version 配置与项目属性是否一致的方法</h4><ol>
<li><p><strong>检查 Qt 版本配置</strong>：</p>
<ul>
<li>打开 Visual Studio 2022，并确保已安装 Qt Visual Studio Tools 插件。</li>
<li>打开 Qt 项目设置：<ul>
<li>在菜单栏中，选择“工具（Tools）”-&gt;“选项（Options）”。</li>
<li>在左侧面板中，找到“Qt Project Settings”或类似选项（根据安装插件，Qt 项目设置可能在“Projects and Solutions”或单独的 Qt 选项卡下）。</li>
</ul>
</li>
<li>检查 Qt 版本：<ul>
<li>在“Qt Project Settings”中，查看“Qt Versions”，这里列出已配置的 Qt 版本。确保已选择正确版本，且该版本指向安装的 Qt 路径。</li>
<li>若 Qt 版本没配置或者未显示想要的版本，可点击“添加（Add）”按钮，选择正确的 Qt 安装路径。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>检查项目属性</strong>：</p>
<ul>
<li>打开项目属性：<ul>
<li>在解决方案资源管理器中，右键点击项目（例如 WBoard.vcxproj），然后选择“属性（Properties）”。</li>
</ul>
</li>
<li>检查 Qt 版本是否一致：<ul>
<li>在项目属性窗口中，选择“配置属性”-&gt;“Qt 项目（Qt Project）”。</li>
<li>在“Qt 版本”字段，确保它与上述配置中的 Qt 版本一致，若不一致，手动选择正确的 Qt 版本。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>检查 Qt 模块</strong>：</p>
<ul>
<li>在“Qt 项目”设置中，查看“Qt Modules”。</li>
<li>确保项目使用了正确的 Qt 模块（例如 QtCore, QtWidgets, QtGui 等），且这些模块与选择的 Qt 版本兼容。</li>
</ul>
</li>
<li><p><strong>重新生成项目</strong>：</p>
<ul>
<li>选择顶部菜单栏中的“生成（Build）”。</li>
<li>点击“重新生成解决方案（Rebuild Solution）”以确保所有配置被正确应用。</li>
</ul>
</li>
<li><p><strong>检查输出日志</strong>：<br>在重新生成项目时，查看输出窗口中的日志，看是否有关于 Qt 配置的错误信息，若 Qt 版本配置不正确，通常会看到类似“No Qt version assigned”或“Qt version mismatch”的错误信息。</p>
</li>
</ol>
<h4 id="三、Visual-Studio-Installer-中安装-MSVC-v142-工具链的步骤及相关事项"><a href="#三、Visual-Studio-Installer-中安装-MSVC-v142-工具链的步骤及相关事项" class="headerlink" title="三、Visual Studio Installer 中安装 MSVC v142 工具链的步骤及相关事项"></a>三、Visual Studio Installer 中安装 MSVC v142 工具链的步骤及相关事项</h4><ol>
<li><p><strong>详细步骤说明</strong>：</p>
<ul>
<li><strong>打开 Visual Studio Installer</strong>：<ul>
<li>在 Windows 搜索栏中输入“Visual Studio Installer”，点击打开。</li>
</ul>
</li>
<li><strong>选择要修改的 VS2022 版本</strong>：<ul>
<li>在安装器中找到已安装的“Visual Studio 2022”，点击右侧的“修改”按钮。</li>
</ul>
</li>
<li><strong>切换到“单个组件”标签页</strong>：<ul>
<li>在弹出的界面中，顶部有多个标签页（工作负载、单个组件、语言包等），点击“单个组件”。</li>
</ul>
</li>
<li><strong>搜索并勾选 MSVC v142 工具链</strong>：<ul>
<li>在搜索框中输入“v142”，找到以下组件并勾选：<ul>
<li>“MSVC v142 - VS2019 C++ x64&#x2F;x86 生成工具（最新）”（确保勾选的是针对 VS2019 的 v142 版本，而非 v143）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>完成修改并安装</strong>：<ul>
<li>点击右下角的“修改”按钮，等待安装完成。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li><strong>权限问题</strong>：<ul>
<li>如果提示需要管理员权限，请以管理员身份运行 Visual Studio Installer。</li>
</ul>
</li>
<li><strong>组件名称可能随版本变化</strong>：<ul>
<li>如果搜索不到“v142”，尝试关键词“VS2019”或“C++ 2019”。</li>
</ul>
</li>
<li><strong>工具链路径验证</strong>：<ul>
<li>安装完成后，工具链默认路径为：“C:\Program Files (x86)\Microsoft Visual Studio\2019\BuildTools\VC\Tools\MSVC\14.29.30133\”（路径中的版本号可能不同）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>为什么需要安装 MSVC v142？</strong>：</p>
<ul>
<li>若使用的 Qt 版本是“Qt 5.15.2 (msvc2019)”，它依赖的是 VS2019 的编译器（MSVC v142）。</li>
<li>VS2022 默认安装的是“MSVC v143”编译器，两者不兼容，通过安装 v142 工具链，可以让 VS2022 兼容旧版 Qt。</li>
</ul>
</li>
<li><p><strong>验证是否安装成功</strong>：</p>
<ul>
<li>打开 VS2022，创建一个空的 C++ 控制台项目。</li>
<li>右键项目 &gt;“属性”&gt;“配置属性”&gt;“常规”，检查“平台工具集”是否包含“Visual Studio 2019 (v142)”。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/15/error_in_VS/" data-id="cm8fndp5f0004xlptgz9ta2a0" data-title="VS上qt配置的若干问题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-wsl_network_error" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/11/15/wsl_network_error/" class="article-date">
  <time class="dt-published" datetime="2024-11-15T08:00:00.000Z" itemprop="datePublished">2024-11-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/11/15/wsl_network_error/">WSL2的网络问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Ubuntu-APT-Update-卡住的排查与解决方案"><a href="#Ubuntu-APT-Update-卡住的排查与解决方案" class="headerlink" title="Ubuntu APT Update 卡住的排查与解决方案"></a>Ubuntu APT Update 卡住的排查与解决方案</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在使用 Ubuntu 进行 <code>sudo apt-get update</code> 时，发现更新一直卡在 <code>Connecting to 172.23.153.121</code>，并最终超时。起初以为是网络问题，但 <code>ping archive.ubuntu.com</code> 和 <code>ping security.ubuntu.com</code> 都能返回数据，说明基础网络是通的。</p>
<p>深入排查后，发现 <code>APT</code> 可能被配置了错误的代理或镜像源，导致更新请求被错误地重定向到 <code>172.23.153.121</code>，最终导致超时。以下是详细的排查过程和解决方案。</p>
<hr>
<h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><h3 id="1-检查-APT-源是否正确"><a href="#1-检查-APT-源是否正确" class="headerlink" title="1. 检查 APT 源是否正确"></a>1. 检查 APT 源是否正确</h3><p>首先查看 <code>/etc/apt/sources.list</code>，确认是否存在错误的源配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<p>我的 <code>sources.list</code> 内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deb http://archive.ubuntu.com/ubuntu focal main restricted universe multiverse</span><br><span class="line">deb http://security.ubuntu.com/ubuntu focal-security main restricted universe multiverse</span><br><span class="line">deb http://archive.ubuntu.com/ubuntu focal-updates main restricted universe multiverse</span><br></pre></td></tr></table></figure>

<p>看起来没有问题，说明问题不是由于源地址错误引起的。</p>
<hr>
<h3 id="2-检查-APT-代理设置"><a href="#2-检查-APT-代理设置" class="headerlink" title="2. 检查 APT 代理设置"></a>2. 检查 APT 代理设置</h3><p>APT 可能被配置了一个错误的代理，导致所有请求都被重定向。检查 <code>apt.conf.d</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r <span class="string">&quot;172.23.153.121&quot;</span> /etc/apt/apt.conf.d/</span><br></pre></td></tr></table></figure>

<p>果然，发现了类似的代理配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/apt/apt.conf.d/00proxy:Acquire::http::Proxy &quot;http://172.23.153.121:80/&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="解决方案：删除或修改该文件"><a href="#解决方案：删除或修改该文件" class="headerlink" title="解决方案：删除或修改该文件"></a>解决方案：删除或修改该文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /etc/apt/apt.conf.d/00proxy</span><br></pre></td></tr></table></figure>
<p>或者手动编辑：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/apt/apt.conf.d/00proxy</span><br></pre></td></tr></table></figure>
<p>删除 <code>Acquire::http::Proxy</code> 相关的行，保存退出。</p>
<hr>
<h3 id="3-检查环境变量中的代理"><a href="#3-检查环境变量中的代理" class="headerlink" title="3. 检查环境变量中的代理"></a>3. 检查环境变量中的代理</h3><p>如果 <code>apt.conf.d</code> 没有问题，可能是系统环境变量导致的。执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">env</span> | grep -i proxy</span><br></pre></td></tr></table></figure>
<p>如果返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=http://172.23.153.121:80</span><br><span class="line">https_proxy=http://172.23.153.121:80</span><br></pre></td></tr></table></figure>
<p>那么需要取消代理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> http_proxy</span><br><span class="line"><span class="built_in">unset</span> https_proxy</span><br></pre></td></tr></table></figure>
<p>并检查 <code>bash</code> 配置文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i proxy ~/.bashrc ~/.bash_profile ~/.profile /etc/environment /etc/bash.bashrc /etc/profile</span><br></pre></td></tr></table></figure>
<p>如果发现 <code>export http_proxy</code> 或 <code>export https_proxy</code>，需要手动编辑相应文件删除，并执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/environment</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-清除-APT-缓存并重试"><a href="#4-清除-APT-缓存并重试" class="headerlink" title="4. 清除 APT 缓存并重试"></a>4. 清除 APT 缓存并重试</h3><p>清除旧的 APT 数据，防止缓存影响：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span><br><span class="line"><span class="built_in">sudo</span> apt-get clean</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="5-检查-DNS-设置"><a href="#5-检查-DNS-设置" class="headerlink" title="5. 检查 DNS 设置"></a>5. 检查 DNS 设置</h3><p>如果问题依然存在，可能是 DNS 解析问题。查看 DNS 配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/resolv.conf</span><br></pre></td></tr></table></figure>
<p>如果 DNS 服务器不是 <code>8.8.8.8</code> 或 <code>8.8.4.4</code>，可以手动修改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/resolv.conf</span><br></pre></td></tr></table></figure>
<p>添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 8.8.4.4</span><br></pre></td></tr></table></figure>
<p>然后再次运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-强制-APT-使用-IPv4"><a href="#6-强制-APT-使用-IPv4" class="headerlink" title="6. 强制 APT 使用 IPv4"></a>6. 强制 APT 使用 IPv4</h3><p>如果仍然超时，尝试强制 APT 仅使用 IPv4：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update -o Acquire::ForceIPv4=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-更换国内镜像源（可选）"><a href="#7-更换国内镜像源（可选）" class="headerlink" title="7. 更换国内镜像源（可选）"></a>7. 更换国内镜像源（可选）</h3><p>如果你在国内，使用官方的 <code>archive.ubuntu.com</code> 可能会较慢，可以更换为阿里云或清华源。</p>
<p>编辑 <code>/etc/apt/sources.list</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>替换为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.aliyun.com/ubuntu focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu focal-updates main restricted universe multiverse</span><br></pre></td></tr></table></figure>
<p>然后更新：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><strong>检查 APT 代理配置</strong> (<code>/etc/apt/apt.conf.d/</code>)，删除错误的代理设置。</li>
<li><strong>检查系统环境变量</strong> (<code>env | grep -i proxy</code>)，删除不必要的代理。</li>
<li><strong>清理 APT 缓存</strong> (<code>sudo rm -rf /var/lib/apt/lists/* &amp;&amp; sudo apt-get clean</code>)。</li>
<li><strong>修复 DNS 设置</strong> (<code>sudo nano /etc/resolv.conf</code>，改成 <code>8.8.8.8</code>)。</li>
<li><strong>强制使用 IPv4</strong> (<code>sudo apt-get update -o Acquire::ForceIPv4=true</code>)。</li>
<li><strong>更换国内镜像源</strong>（阿里云、清华等）。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/11/15/wsl_network_error/" data-id="cm8fndp5l0006xlpt6vc51te1" data-title="WSL2的网络问题" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">November 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/17/aa/">文章标题</a>
          </li>
        
          <li>
            <a href="/2025/03/17/album/">QT电子相册题目</a>
          </li>
        
          <li>
            <a href="/2025/03/17/task1/">FreeRTOS中的任务实现</a>
          </li>
        
          <li>
            <a href="/2025/03/16/VS2022&MSVC2019/">VS2022不支持MSVC2019</a>
          </li>
        
          <li>
            <a href="/2025/03/15/Singleton/">懒汉模式与饿汉模式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>